# -*- coding: utf-8 -*-
"""Anime Recommendation System.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hE9shvidQz3fayRA0pQgi4C_MRiXKZOe

Let's start by taking a look at its structure to understand the kind of data it contains. I'll load the dataset and display the first few rows.

Let's proceed with that.

The dataset consists of the following columns:

**anime_id:**Unique identifier for each anime.

**name:** Name of the anime.

**genre:** Genres associated with the anime.

**type:** Type of anime (e.g., TV, Movie).

**episodes:**Number of episodes.

**rating:** Average rating.

**members:** Number of members who have rated the anime.
"""

import pandas as pd

anime = pd.read_csv("/content/anime.csv")

anime.head()

"""**Data Exploration**

"""

anime.head()
anime.info()
anime.describe()

print(anime.isnull().sum())

"""The dataset has missing values in the following columns:

genre: 62 missing values
type: 25 missing values
rating: 230 missing values

Dropping all the null vaue columns
"""

anime.dropna(subset=['genre'], inplace=True)

anime.dropna(subset=['type'], inplace=True)
anime.dropna(subset=['rating'], inplace=True)

print(anime.isnull().sum())

"""**Data Analysis through visualisation**

First chart explains the ratings of the anime's with the help of matplotlib and seaborn.

1.**Rating Distribution**

A histogram of the **rating** column to see the distribution of ratings.
Calculating the mean, median, and standard deviation of the ratings.
"""

# Plot rating distribution
import matplotlib.pyplot as plt
import seaborn as sns
plt.hist(anime['rating'], bins=50)
plt.xlabel('Rating')
plt.ylabel('Frequency')
plt.title('Rating Distribution')
plt.show()

""" 2. **Most Popular Anime**

Plotting a bar chart to show the top 10 anime with the most members.
"""

most_popular_anime = anime.nlargest(10, 'members')
sns.barplot(x=most_popular_anime['name'], y=most_popular_anime['members'])
plt.xlabel('Anime Name')
plt.ylabel('Members')
plt.xticks(rotation=90, fontsize=6)  # reduce font size to 6
plt.title('Top 10 Most Popular Anime')
plt.show()

"""3. **Top Genres**

 A bar chart with the top 10 anime names on the x-axis,
"""

import matplotlib.pyplot as plt

# Get the top 10 genres
top_genres = anime['genre'].value_counts().nlargest(10)

# Plot the top 10 genres
plt.figure(figsize=(10, 6))
plt.bar(top_genres.index, top_genres.values)
plt.xlabel('Genre')
plt.ylabel('Frequency')
plt.title('Top 10 Genres')
plt.xticks(rotation=90, fontsize=10)  # adjust font size and rotation
plt.tight_layout()  # ensure labels fit within the figure area
plt.show()

"""4**. Top Rated Animes**

This graph shows a heatmap of the ratings of the top 10 rated anime, with darker colors indicating higher ratings.
"""

# Get the top 10 rated anime
top_rated_anime = anime.nlargest(10, 'rating')

# Create a heatmap of anime ratings
plt.figure(figsize=(10, 6))
sns.heatmap(top_rated_anime.pivot_table(index='name', values='rating', aggfunc='mean'), annot=True, cmap='coolwarm', square=True)
plt.title('Top Rated Anime: Rating Heatmap')
plt.show()

"""5. **Rating V/S Members**

This Scatter Plot helps in anime fans, creators, and industry professionals better understand the relationship between popularity and quality in anime, and make more informed decisions about which anime to watch, create, or invest in.
"""

# Create a scatter plot
plt.figure(figsize=(10, 6))
plt.scatter(anime['members'], anime['rating'])
plt.xlabel('Number of Members')
plt.ylabel('Rating')
plt.title('Rating vs. Number of Members')
plt.show()

"""Dropping the ''Unknown' value rows in 'Episodes' column to make it easy to convert them into numerical vectors as strings cannot be converted into float"""

# Drop rows where episodes is 'Unknown'
anime_data = anime[anime['episodes'] != 'Unknown']

"""**Building the Recommendation system**"""

from sklearn.metrics.pairwise import cosine_similarity
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.preprocessing import LabelEncoder

# Creating a TF-IDF vectorizer to convert anime descriptions into numerical vectors
vectorizer = TfidfVectorizer(stop_words='english')

# Creating a LabelEncoder to convert categorical features into numerical vectors
le = LabelEncoder()

# Converting genres into numerical vectors
anime_genres = anime_data['genre'].str.split(',').apply(lambda x: ','.join(x))
anime_genre_vectors = vectorizer.fit_transform(anime_genres)

# Converting types into numerical vectors
anime_types = anime_data['type']
anime_type_vectors = le.fit_transform(anime_types)

# Converting ratings into numerical vectors
anime_ratings = anime_data['rating']
anime_rating_vectors = anime_ratings.values.reshape(-1, 1)

# Concatenating the feature vectors
anime_genre_vectors_df = pd.DataFrame(anime_genre_vectors.toarray())
anime_type_vectors_df = pd.DataFrame(anime_type_vectors)
anime_rating_vectors_df = pd.DataFrame(anime_rating_vectors)

# Concatenating the feature vectors
anime_vectors = pd.concat([
    anime_genre_vectors_df,
    anime_type_vectors_df,
    anime_rating_vectors_df
], axis=1)

# Calculating the cosine similarity between anime vectors
similarity_matrix = cosine_similarity(anime_vectors)

# Creating a dictionary to map anime names to their indices
anime_index = {anime: idx for idx, anime in enumerate(anime_data['name'])}

def get_recommendations(anime_name, num_recs=5):
    # Get the index of the input anime
    anime_idx = anime_index.get(anime_name)

    # If the anime is not found, return an error message
    if anime_idx is None:
        return "Anime not found!"

    # Get the similarity scores for the input anime
    similarity_scores = similarity_matrix[anime_idx]

    # Get the top-N similar anime
    similar_anime = similarity_scores.argsort()[-num_recs-1:-1]

    # Creating a table with the recommended anime
    recs_table = anime_data.iloc[similar_anime][['anime_id', 'name', 'type', 'genre', 'episodes']]

    return recs_table

# Example usage
anime_name = "Naruto"  # Replace with an anime name
num_recs = 5

recs = get_recommendations(anime_name, num_recs)
print(recs)





